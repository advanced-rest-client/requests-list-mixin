<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/lib/utils/mixin.html">
<script>
(function(global) {
'use strict';
if (!global.ArcComponents) {
  /**
   * @namespace ArcComponents
   */
  global.ArcComponents = {};
}
/**
 * A mixin to be used with elements that consumes lists of requests.
 * It implements event listeners related to requests data change.
 *
 * @polymer
 * @mixinFunction
 * @memberof ArcComponents
 */
global.ArcComponents.RequestsListMixin = Polymer.dedupingMixin((base) => {
  /**
   * @polymer
   * @mixinClass
   */
  class RLmixin extends base {
    static get properties() {
      return {
        /**
         * The list of request to render.
         * It can be eirther saved, history or project items.
         * @type {Array<Object>}
         */
        requests: Array,
        /**
         * Computed value, true when the project has requests.
         */
        hasRequests: {
          type: Boolean,
          value: false,
          computed: '_computeHasRequests(requests.length)',
          notify: true
        },
        /**
         * Requests list type. Can be one of:
         * - saved
         * - history
         * - project
         *
         * Depending on the the type request change event is handled differently.
         * For saved and history requests corresponding type is processed.
         * For project requests list only request that has project id in the
         * projects list is processed.
         *
         * This property must be set.
         */
        type: String,
        /**
         * Project datastore ID to display.
         * This should be set only when type is `project`
         */
        projectId: String,
        /**
         * Changes information density of list items.
         * By default it uses material's peper item with two lines (72px heigth)
         * Possible values are:
         *
         * - `default` or empty - regular list view
         * - `comfortable` - enables MD single line list item vie (52px heigth)
         * - `compact` - enables list that has 40px heigth (touch recommended)
         */
        listType: {
          type: String,
          reflectToAttribute: true,
          observer: '_updateListStyles'
        },
        /**
         * Computed value if the list item should be consisted of two lines of
         * description.
         */
        _hasTwoLines: {value: true, type: Boolean, computed: '_computeHasTwoLines(listType)'}
      };
    }

    constructor() {
      super();
      this._requestDeletedHandler = this._requestDeletedHandler.bind(this);
      this._requestChangedHandler = this._requestChangedHandler.bind(this);
    }

    connectedCallback() {
      super.connectedCallback();
      window.addEventListener('request-object-deleted', this._requestDeletedHandler);
      window.addEventListener('request-object-changed', this._requestChangedHandler);
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      window.removeEventListener('request-object-deleted', this._requestDeletedHandler);
      window.removeEventListener('request-object-changed', this._requestChangedHandler);
    }
    /**
     * Handler for `request-object-deleted` event. Removes request from the list
     * if it existed.
     * @param {CustomEvent} e
     */
    _requestDeletedHandler(e) {
      const requests = this.requests;
      if (e.cancelable || !requests || !requests.length) {
        return;
      }
      const deleteId = e.detail.id;
      for (let i = 0, len = requests.length; i < len; i++) {
        if (requests[i]._id === deleteId) {
          this.splice('requests', i, 1);
          return;
        }
      }
    }
    /**
     * Handler for `request-object-changed` custom event.
     * Depending on the `type` property it updates / adds / removes item from
     * the requests list.
     * @param {CustomEvent} e
     */
    _requestChangedHandler(e) {
      if (e.cancelable) {
        return;
      }
      const request = e.detail.request;
      switch (this.type) {
        case 'history':
          this._historyTypeChanged(request);
          break;
        case 'saved':
          this._savedTypeChanged(request);
          break;
        case 'project':
          this._projectTypeChanged(request);
          break;
      }
    }
    /**
     * Handles request change when type is project.
     * @param {Object} request Changed request object.
     */
    _projectTypeChanged(request) {
      const projectId = this.projectId;
      if (!projectId) {
        return;
      }
      const requests = this.requests;
      if (!requests) {
        if (this._isProjectRequest(request)) {
          this.requests = [request];
        }
        return;
      }
      for (let i = requests.length - 1; i >= 0; i--) {
        if (requests[i]._id === request._id) {
          if (this._isProjectRequest(request)) {
            this.set(`requests.${i}`, request);
          } else {
            this.splice('requests', i, 1);
          }
          return;
        }
      }
      if (this._isProjectRequest(request)) {
        this.push(`requests`, request);
      }
    }
    /**
     * Handles request change when type is saved or history.
     * @param {Object} request Changed request object.
     */
    _savedTypeChanged(request) {
      const t = this.type;
      if (!t) {
        return;
      }
      if (request.type === 'saved') {
        if (t !== 'saved' && t !== 'saved-requests') {
          return;
        }
      } else if (request.type === 'history') {
        if (t !== 'history' && t !== 'history-requests') {
          return;
        }
      }
      const requests = this.requests;
      if (!requests) {
        this.set('requests', [request]);
        return;
      }
      for (let i = 0, len = requests.length; i < len; i++) {
        if (requests[i]._id === request._id) {
          this.set(`requests.${i}`, request);
          return;
        }
      }
      this.unshift('requests', request);
    }
    /**
     * Handles request change when type is saved or history.
     * @param {Object} request Changed request object.
     */
    _historyTypeChanged(request) {
      const t = request.type;
      if (t && t !== 'history' && t !== 'history-requests') {
        return;
      }
      const requests = this.requests;
      if (!requests) {
        return this._unshiftHistoryItem(request);
      }
      const id = request._id;
      for (let i = 0, len = requests.length; i < len; i++) {
        if (requests[i]._id === id) {
          const old = this.requests[i];
          const next = this.requests[i + 1];
          if (old.hasHeader && next && !next.hasHeader) {
            this.set(['requests', i + 1, 'header'], old.header);
            this.set(['requests', i + 1, 'hasHeader'], old.hasHeader);
          }
          if (i === 0) {
            this._appendTodaysHeader(request);
          }
          this.set(['requests', i], request);
          return;
        }
      }
      this._unshiftHistoryItem(request);
    }

    /**
     * Appends "today" header to the item.
     *
     * @param {Object} item History document
     */
    _appendTodaysHeader(item) {
      item.hasHeader = true;
      item.header = 'Today';
      item.today = true;
    }
    /**
     * Adds a new history item to the top of the list.
     * @param {Object} item A history item to add
     */
    _unshiftHistoryItem(item) {
      this._appendTodaysHeader(item);
      const firstItem = this.get(['requests', 0]);
      if (firstItem === undefined) {
        return this.set('requests', [item]);
      }
      if (firstItem && firstItem.today) {
        delete firstItem.hasHeader;
        delete firstItem.header;
        this.set(['requests', 0], firstItem);
      }
      this.unshift('requests', item);
    }
    /**
     * A function to read request data for a project.
     * @param {String} projectId Project ID
     * @return {Promise} Promise.resolved to requests list.
     */
    readProjectRequests(projectId) {
      const e = new CustomEvent('project-read', {
        bubbles: true,
        cancelable: true,
        composed: true,
        detail: {
          id: projectId
        }
      });
      this.dispatchEvent(e);
      if (!e.defaultPrevented) {
        return Promise.reject(new Error(`project-read event not handled`));
      }
      let projectHasRequests;
      e.detail.result
      .then((project) => {
        projectHasRequests = !!project.requests;
        const e = new CustomEvent('request-project-list', {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            id: project._id
          }
        });
        this.dispatchEvent(e);
        if (!e.defaultPrevented) {
          return Promise.reject(new Error('request-project-list event not handled'));
        }
        return e.detail.result;
      })
      .then((requests) => {
        if (!projectHasRequests) {
          requests.sort(this._legacySort);
        }
        return requests;
      });
    }

    /**
     * Sorts requests list by `projectOrder` property
     *
     * @param {Object} a
     * @param {Object} b
     * @return {Number}
     */
    _legacySort(a, b) {
      if (a.projectOrder > b.projectOrder) {
        return 1;
      }
      if (a.projectOrder < b.projectOrder) {
        return -1;
      }
      if (a.name > b.name) {
        return 1;
      }
      if (a.name < b.name) {
        return -1;
      }
      return 0;
    }

    /**
     * Updates requests in bulk opeartion.
     * @param {[type]} items [description]
     * @return {[type]} [description]
     */
    _updateBulk(items) {
      const promises = items.map((item) => this._updateRequest(item));
      return Promise.all(promises);
    }
    /**
     * Sends the `request-object-changed` custom event for each request on the list.
     * @param {Object} request Request object.
     * @return {Promise} Promise resolved when the request object is updated.
     */
    _updateRequest(request) {
      let type;
      switch (this.type) {
        case 'saved':
        case 'project':
          type = 'saved';
          break;
        case 'history':
          type = 'history';
          break;
      }
      if (!type) {
        return Promise.reject('Unknown request type');
      }
      const e = new CustomEvent('request-object-changed', {
        bubbles: true,
        cancelable: true,
        composed: true,
        detail: {
          type,
          request
        }
      });
      this.dispatchEvent(e);
      if (!e.defaultPrevented) {
        return Promise.reject(new Error('Request model not found'));
      }
      return e.detail.result;
    }

    _computeHasRequests(length) {
      return !!length;
    }
    /**
     * Computes value for `_hasTwoLines` property.
     * @param {?String} listType Selected list type.
     * @return {Boolean}
     */
    _computeHasTwoLines(listType) {
      if (!listType || listType === 'default') {
        return true;
      }
      return false;
    }
    /**
     * Updates icon size CSS variable and notifies resize on the list when
     * list type changes.
     * @param {?String} type
     */
    _updateListStyles(type) {
      let size;
      switch (type) {
        case 'comfortable': size = 48; break;
        case 'compact': size = 36; break;
        default: size = 72; break;
      }
      this.updateStyles({
        '--paper-item-icon-width': `${size}px`
      });
      if (this.notifyResize) {
        this.notifyResize();
      }
    }
    /**
     * Creates a headers for each day and group requests in each day group.
     * This is relevant for history type
     *
     * @param {Array<Object>} requests
     * @param {Number} today Timestamp of today
     * @param {Number} yesterday Timestamp of yesterday
     */
    _groupHistory(requests, today, yesterday) {
      const days = [];
      const result = [];
      requests.forEach((item) => {
        const info = this._computeHistoryTime(item.updated || item.created);
        if (!info) {
          return;
        }
        item.timeLabel = info.timeLabel;
        let date = info.formatted;
        if (days.indexOf(date) === -1) {
          days[days.length] = date;
          let time = info.time;
          if (time === today) {
            item.today = true;
            date = 'Today';
          } else if (time === yesterday) {
            date = 'Yesterday';
          }
          item.hasHeader = true;
          item.header = date;
        }
        result.push(item);
      });
      return result;
    }
    /**
     * Computes time information for a history item. This is later used to
     * present history list item.
     * @param {Number} date Timestamp of when the item was created / updated
     * @return {Object} Various time formats:
     * - formatted - Formatted date string
     * - time - Parsed timestamp
     * - timeLabel - secondary list item
     */
    _computeHistoryTime(date) {
      if (!date) {
        return;
      }
      const d = new Date(date);
      if (isNaN(d)) {
        return;
      }
      const formatted = new Intl.DateTimeFormat(undefined, {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      }).format(d);
      const timeLabel = new Intl.DateTimeFormat(undefined, {
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric'
      }).format(d);
      d.setHours(0, 0, 0, 0);
      const time = d.getTime();
      return {
        formatted,
        time,
        timeLabel
      };
    }
    /**
     * Creates a timestamp fot today, midnight
     * @return {Number}
     */
    _getTodayTimestamp() {
      const now = new Date();
      now.setHours(0, 0, 0, 0);
      return now.getTime();
    }
    /**
     * Computes yesterday's midninght based on today's mignight timestamp
     * @param {Number} todayTimestamp Timestamp of current daty at midnight
     * @return {Number} Timestamp 24 hours earlier.
     */
    _getYesterdayTimestamp(todayTimestamp) {
      return todayTimestamp - 86400000; // 24 h in milliseconds
    }
    /**
     * Processes query results to generate view data model.
     * @param {Array} res List of history requests retreived from the datastore.
     * @return {Array} Processed data requests.
     */
    _processHistoryResults(res) {
      res = this._ensureTimestamps(res);
      res.sort(this._sortHistoryResults);
      const today = this._getTodayTimestamp();
      const yesterday = this._getYesterdayTimestamp(today);
      res = this._groupHistory(res, today, yesterday);
      return res;
    }
    /**
     * Ensures that the history objects have the `updated` property
     * required by further computations while processing results.
     *
     * @param {Array<Object>} requests List of history requests
     * @return {Array<Object>} The same array but all requests will have `updated`
     * property.
     */
    _ensureTimestamps(requests) {
      return requests.map((item) => {
        if (!item.created) {
          item.created = Date.now();
        }
        if (!item.updated || isNaN(item.updated)) {
          if (item.created && !isNaN(item.created)) {
            item.updated = item.created;
          } else {
            item.updated = Date.now();
          }
        }
        return item;
      });
    }
    // Sorts the query results by `updated` property.
    _sortHistoryResults(a, b) {
      if (a.updated > b.updated) {
        return -1;
      }
      if (a.updated < b.updated) {
        return 1;
      }
      return 0;
    }
  }
  return RLmixin;
});
})(window);
</script>
</dom-module>

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>requests-list-mixin test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

</head>
<body>
  <test-fixture id="Basic">
    <template>
      <test-element-history></test-element-history>
    </template>
  </test-fixture>

  <test-fixture id="BasicSaved">
    <template>
      <test-element-saved></test-element-saved>
    </template>
  </test-fixture>

  <test-fixture id="Comfortable">
    <template>
      <test-element-history list-type="comfortable"></test-element-history>
    </template>
  </test-fixture>

  <test-fixture id="Compact">
    <template>
      <test-element-history list-type="compact"></test-element-history>
    </template>
  </test-fixture>

  <test-fixture id="Default">
    <template>
      <test-element-history list-type="default"></test-element-history>
    </template>
  </test-fixture>

  <test-fixture id="History">
    <template>
      <test-element-history type="history"></test-element-history>
    </template>
  </test-fixture>

  <script type="module">
  import {DataGenerator} from '../../../arc-data-generator/arc-data-generator.js';
  import './test-element-history.js';
  import './test-element-saved.js';
  
  suite('hasRequests property', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Has default value', () => {
      assert.isFalse(element.hasRequests);
    });

    test('Is true when has requests', () => {
      element.requests = [{
        _id: 'test'
      }];
      assert.isTrue(element.hasRequests);
    });

    test('Is false when requests are cleared', () => {
      element.requests = [{
        _id: 'test'
      }];
      flush(() => {
        element.requests = undefined;
        assert.isFalse(element.hasRequests);
      });
    });
  });

  suite('_dispatch()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });
    const eName = 'test-event';
    const eDetail = 'test-detail';
    test('Dispatches an event', () => {
      const spy = sinon.spy();
      element.addEventListener(eName, spy);
      element._dispatch(eName);
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const e = element._dispatch(eName);
      assert.typeOf(e, 'customevent');
    });

    test('Event is cancelable', () => {
      const e = element._dispatch(eName);
      assert.isTrue(e.cancelable);
    });

    test('Event is composed', () => {
      const e = element._dispatch(eName);
      if (typeof e.composed !== 'undefined') {
        assert.isTrue(e.composed);
      }
    });

    test('Event bubbles', () => {
      const e = element._dispatch(eName);
      assert.isTrue(e.bubbles);
    });

    test('Event has detail', () => {
      const e = element._dispatch(eName, eDetail);
      assert.equal(e.detail, eDetail);
    });
  });

  suite('_dispatchProjectRead()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _dispatch()', () => {
      const spy = sinon.spy(element, '_dispatch');
      element._dispatchProjectRead('test');
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const e = element._dispatchProjectRead('test');
      assert.typeOf(e, 'customevent');
    });

    test('Event has type', () => {
      const e = element._dispatchProjectRead('test');
      assert.equal(e.type, 'project-read');
    });

    test('Event has id on detail', () => {
      const e = element._dispatchProjectRead('test-id');
      assert.equal(e.detail.id, 'test-id');
    });
  });

  suite('_dispatchProjectList()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _dispatch()', () => {
      const spy = sinon.spy(element, '_dispatch');
      element._dispatchProjectList('test');
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const e = element._dispatchProjectList('test');
      assert.typeOf(e, 'customevent');
    });

    test('Event has type', () => {
      const e = element._dispatchProjectList('test');
      assert.equal(e.type, 'request-project-list');
    });

    test('Event has id on detail', () => {
      const e = element._dispatchProjectList('test-id');
      assert.equal(e.detail.id, 'test-id');
    });
  });

  suite('_dispatchRequestChanged()', () => {
    let element;
    const requestType = 'saved';
    let request;
    setup(() => {
      element = fixture('Basic');
      request = {name: 'test'};
    });

    test('Calls _dispatch()', () => {
      const spy = sinon.spy(element, '_dispatch');
      element._dispatchRequestChanged(requestType, request);
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const e = element._dispatchRequestChanged(requestType, request);
      assert.typeOf(e, 'customevent');
    });

    test('Event has type', () => {
      const e = element._dispatchRequestChanged(requestType, request);
      assert.equal(e.type, 'request-object-changed');
    });

    test('Event has "type" on detail', () => {
      const e = element._dispatchRequestChanged(requestType, request);
      assert.equal(e.detail.type, requestType);
    });

    test('Event has "request" on detail', () => {
      const e = element._dispatchRequestChanged(requestType, request);
      assert.deepEqual(e.detail.request, request);
    });
  });

  suite('_requestDeletedHandler()', () => {
    let element;
    test('Ignores cancelable events', () => {
      element = fixture('Basic');
      element.requests = DataGenerator.generateHistoryRequestsData({
        requestsSize: 10
      });
      element._requestDeletedHandler({
        cancelable: true,
        detail: {
          id: element.requests[0]._id
        }
      });
      assert.lengthOf(element.requests, 10);
    });

    test('Ignores the event when no requests', () => {
      element = fixture('Basic');
      element.requests = [];
      element._requestDeletedHandler({
        cancelable: true,
        detail: {
          id: 'test'
        }
      });
      assert.lengthOf(element.requests, 0);
    });

    test('Ignores the event when requests are undefined', () => {
      element = fixture('Basic');
      element._requestDeletedHandler({
        cancelable: true,
        detail: {
          id: 'test'
        }
      });
      assert.isUndefined(element.requests);
    });

    test('Calls _historyItemDeleted() when element\'s type is "history"', () => {
      element = fixture('Basic');
      element.requests = DataGenerator.generateHistoryRequestsData({
        requestsSize: 10
      });
      const spy = sinon.spy(element, '_historyItemDeleted');
      const id = element.requests[4]._id;
      element._requestDeletedHandler({
        cancelable: false,
        detail: {
          id
        }
      });
      assert.isTrue(spy.called);
      assert.equal(spy.args[0][0], id);
    });

    test('Calls _itemDeleted() when element\'s type is "saved"', () => {
      element = fixture('BasicSaved');
      element.requests = DataGenerator.generateRequests({
        requestsSize: 10
      });
      const spy = sinon.spy(element, '_itemDeleted');
      const id = element.requests[4]._id;
      element._requestDeletedHandler({
        cancelable: false,
        detail: {
          id
        }
      });
      assert.isTrue(spy.called);
      assert.equal(spy.args[0][0], id);
    });
  });

  suite('_itemDeleted()', () => {
    let element;
    setup(() => {
      element = fixture('BasicSaved');
      element.requests = DataGenerator.generateRequests({
        requestsSize: 10
      });
    });

    test('Removes existing item', () => {
      element._itemDeleted(element.requests[4]._id);
      assert.lengthOf(element.requests, 9);
    });

    test('Ignores item if not found', () => {
      element._itemDeleted('non-existing');
      assert.lengthOf(element.requests, 10);
    });
  });

  suite('_historyItemDeleted()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      element.requests = DataGenerator.generateHistoryRequestsData({
        requestsSize: 10
      });
    });

    test('Removes existing item', () => {
      element._historyItemDeleted(element.requests[4]._id);
      assert.lengthOf(element.requests, 9);
    });

    test('Ignores item if not found', () => {
      element._historyItemDeleted('non-existing');
      assert.lengthOf(element.requests, 10);
    });

    test('Adds header to next item', () => {
      const id = element.requests[4]._id;
      element.requests[4].hasHeader = true;
      element.requests[4].header = 'test-header';
      element.requests[5].hasHeader = false;
      element._historyItemDeleted(id);
      assert.lengthOf(element.requests, 9);
      const item = element.requests[4];
      assert.isTrue(item.hasHeader, 'hasHeader is set');
      assert.equal(item.header, 'test-header', 'header is set');
    });

    test('Will not update header when next item has own header', () => {
      const id = element.requests[4]._id;
      element.requests[4].hasHeader = true;
      element.requests[4].header = 'test-header';
      element.requests[5].hasHeader = true;
      element.requests[5].header = 'other-header';
      element._historyItemDeleted(id);
      assert.lengthOf(element.requests, 9);
      const item = element.requests[4];
      assert.equal(item.header, 'other-header', 'header is mot updated');
    });
  });

  suite('_requestChangedHandler()', () => {
    test('Do nothing when event is cancelable', () => {
      const element = fixture('Basic');
      element._requestChangedHandler({
        cancelable: true,
        detail: {
          request: {_id: 'test'}
        }
      });
      assert.isUndefined(element.requests);
    });

    test('Calls "_historyTypeChanged()" for history type - if exists', () => {
      const element = fixture('Basic');
      element._historyTypeChanged = () => {};
      const item = DataGenerator.generateHistoryObject();
      const spy = sinon.spy(element, '_historyTypeChanged');
      element._requestChangedHandler({
        detail: {
          request: item
        }
      });
      assert.isTrue(spy.called, 'Function was called');
      assert.deepEqual(spy.args[0][0], item, 'Argument is set');
    });

    test('Ignores call to "_historyTypeChanged()" if not exists', () => {
      const element = fixture('Basic');
      const item = DataGenerator.generateHistoryObject();
      element._requestChangedHandler({
        detail: {
          request: item
        }
      });
      // No error
    });

    test('Calls "_savedTypeChanged()" for saved type', () => {
      const element = fixture('BasicSaved');
      const item = DataGenerator.generateSavedItem();
      const spy = sinon.spy(element, '_savedTypeChanged');
      element._requestChangedHandler({
        detail: {
          request: item
        }
      });
      assert.isTrue(spy.called, 'Function was called');
      assert.deepEqual(spy.args[0][0], item, 'Argument is set');
    });

    test('Calls "_projectTypeChanged()" for saved type', () => {
      const element = fixture('BasicSaved');
      element.type = 'project';
      const item = DataGenerator.generateSavedItem();
      const spy = sinon.spy(element, '_projectTypeChanged');
      element._requestChangedHandler({
        detail: {
          request: item
        }
      });
      assert.isTrue(spy.called, 'Function was called');
      assert.deepEqual(spy.args[0][0], item, 'Argument is set');
    });
  });

  suite('_projectTypeChanged()', () => {
    let element;
    const projectId = 'test-project';
    setup(() => {
      element = fixture('Basic');
      element.type = 'project';
      element.projectId = projectId;
      const requests = DataGenerator.generateRequests({
        requestsSize: 10
      });
      requests.forEach((item) => item.projects = [projectId]);
      element.requests = requests;
    });

    function genProjectItem() {
      const item = DataGenerator.generateSavedItem();
      item.projects = [projectId];
      return item;
    }

    test('Does nothing when no project id', () => {
      element.projectId = undefined;
      const item = genProjectItem();
      element._projectTypeChanged(item);
      assert.lengthOf(element.requests, 10);
    });

    test('Creates requests array', () => {
      element.requests = undefined;
      const item = genProjectItem();
      element._projectTypeChanged(item);
      assert.lengthOf(element.requests, 1);
    });

    test('Ignores item if not related to the project and no requests', () => {
      element.requests = undefined;
      const item = genProjectItem();
      item.projects = ['other'];
      element._projectTypeChanged(item);
      assert.isUndefined(element.requests);
    });

    test('Adds new item to requests array', () => {
      const item = genProjectItem();
      element._projectTypeChanged(item);
      assert.lengthOf(element.requests, 11);
    });

    test('Adds new item to requests array at position', () => {
      const item = genProjectItem();
      const project = DataGenerator.createProjectObject();
      project._id = projectId;
      project.requests = element.requests.map((item) => item._id);
      project.requests.splice(1, 0, item._id);
      element.project = project;
      element._projectTypeChanged(item);
      assert.lengthOf(element.requests, 11);
      assert.deepEqual(element.requests[1], item);
    });

    test('Updates existing item', () => {
      const item = Object.assign({}, element.requests[2]);
      item.name = 'test-name';
      element._projectTypeChanged(item);
      assert.lengthOf(element.requests, 10);
      assert.equal(element.requests[2].name, 'test-name');
    });

    test('Removes item is no longer related to project', () => {
      const item = Object.assign({}, element.requests[2]);
      item.projects = undefined;
      item.legacyProject = undefined;
      element._projectTypeChanged(item);
      assert.lengthOf(element.requests, 9);
    });

    test('Ignores item not related to the project', () => {
      const item = genProjectItem();
      item.projects = ['non-existing-id'];
      element._projectTypeChanged(item);
      assert.lengthOf(element.requests, 10);
    });
  });

  suite('_isProjectRequest()', () => {
    let element;
    const projectId = 'test-project';
    setup(() => {
      element = fixture('Basic');
      element.type = 'project';
      element.projectId = projectId;
    });

    test('Returns false when no project id', () => {
      element.projectId = undefined;
      const item = DataGenerator.generateSavedItem();
      const result = element._isProjectRequest(item);
      assert.isFalse(result);
    });

    test('Returns false when item is not related to current project', () => {
      const item = DataGenerator.generateSavedItem();
      const result = element._isProjectRequest(item);
      assert.isFalse(result);
    });

    test('Returns false when item has other prjects', () => {
      const item = DataGenerator.generateSavedItem();
      item.projects = ['other'];
      const result = element._isProjectRequest(item);
      assert.isFalse(result);
    });

    test('Returns true when project is on projects list', () => {
      const item = DataGenerator.generateSavedItem();
      item.projects = [projectId];
      const result = element._isProjectRequest(item);
      assert.isTrue(result);
    });

    test('Returns true when project is set on legacyProject', () => {
      const item = DataGenerator.generateSavedItem();
      item.legacyProject = projectId;
      const result = element._isProjectRequest(item);
      assert.isTrue(result);
    });
  });

  suite('_savedTypeChanged()', () => {
    let element;
    setup(() => {
      element = fixture('BasicSaved');
      element.requests = DataGenerator.generateRequests({
        requestsSize: 10
      });
    });
    test('Do nothing when type is not set', () => {
      element.type = undefined;
      const item = DataGenerator.generateSavedItem();
      element._savedTypeChanged(item);
      assert.lengthOf(element.requests, 10);
    });

    test('Do nothing when type is not saved', () => {
      element.type = 'history';
      const item = DataGenerator.generateSavedItem();
      element._savedTypeChanged(item);
      assert.lengthOf(element.requests, 10);
    });

    test('Do nothing when request type is not saved', () => {
      const item = DataGenerator.generateHistoryObject();
      element._savedTypeChanged(item);
      assert.lengthOf(element.requests, 10);
    });

    test('Creates requests array when request type is "saved"', () => {
      element.requests = undefined;
      const item = DataGenerator.generateSavedItem();
      item.type = 'saved';
      element._savedTypeChanged(item);
      assert.lengthOf(element.requests, 1);
    });

    test('Creates requests array when request type is "saved-requests"', () => {
      element.requests = undefined;
      const item = DataGenerator.generateSavedItem();
      item.type = 'saved-requests';
      element._savedTypeChanged(item);
      assert.lengthOf(element.requests, 1);
    });

    test('Updates existing request', () => {
      const item = Object.assign({}, element.requests[2]);
      item.name = 'test-name';
      element._savedTypeChanged(item);
      assert.lengthOf(element.requests, 10);
      assert.equal(element.requests[2].name, 'test-name');
    });

    test('Adds new request to the top of the list', () => {
      const item = DataGenerator.generateSavedItem();
      element._savedTypeChanged(item);
      assert.lengthOf(element.requests, 11);
      assert.deepEqual(element.requests[0], item);
    });
  });

  suite('_legacySort()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns 1 when a projectOrder is > than b projectOrder', () => {
      const result = element._legacySort({
        projectOrder: 1
      }, {
        projectOrder: 0
      });
      assert.equal(result, 1);
    });

    test('Returns -1 when a projectOrder is < than b projectOrder', () => {
      const result = element._legacySort({
        projectOrder: 0
      }, {
        projectOrder: 1
      });
      assert.equal(result, -1);
    });

    test('Returns 1 when a name is > than b name', () => {
      const result = element._legacySort({
        projectOrder: 0,
        name: 'b'
      }, {
        projectOrder: 0,
        name: 'a'
      });
      assert.equal(result, 1);
    });

    test('Returns -1 when a name is < than b name', () => {
      const result = element._legacySort({
        projectOrder: 0,
        name: 'a'
      }, {
        projectOrder: 0,
        name: 'b'
      });
      assert.equal(result, -1);
    });

    test('Returns 0 when objects equal', () => {
      const result = element._legacySort({
        projectOrder: 0,
        name: 'a'
      }, {
        projectOrder: 0,
        name: 'a'
      });
      assert.equal(result, 0);
    });
  });

  suite('_updateRequest()', () => {
    test('Throws when type is undefined', () => {
      assert.throws(() => {
        const item = DataGenerator.generateHistoryObject();
        const element = fixture('Basic');
        element.type = 'unknown';
        element._updateRequest(item);
      });
    });

    test('Calls _dispatchRequestChanged() for history object', () => {
      const item = DataGenerator.generateHistoryObject();
      const element = fixture('Basic');
      const spy = sinon.spy(element, '_dispatchRequestChanged');
      return element._updateRequest(item)
      .catch(() => {})
      .then(() => {
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'history');
        assert.deepEqual(spy.args[0][1], item);
      });
    });

    test('Calls _dispatchRequestChanged() for saved object', () => {
      const item = DataGenerator.generateSavedItem();
      const element = fixture('BasicSaved');
      const spy = sinon.spy(element, '_dispatchRequestChanged');
      return element._updateRequest(item)
      .catch(() => {})
      .then(() => {
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'saved');
        assert.deepEqual(spy.args[0][1], item);
      });
    });

    test('Calls _dispatchRequestChanged() for saved object in a project', () => {
      const item = DataGenerator.generateSavedItem();
      const element = fixture('BasicSaved');
      element.type = 'project';
      const spy = sinon.spy(element, '_dispatchRequestChanged');
      return element._updateRequest(item)
      .catch(() => {})
      .then(() => {
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'saved');
        assert.deepEqual(spy.args[0][1], item);
      });
    });

    test('Rejects the promise when no model', () => {
      const item = DataGenerator.generateSavedItem();
      const element = fixture('BasicSaved');
      return element._updateRequest(item)
      .catch((cause) => {
        assert.equal(cause.message, 'Request model not found');
      });
    });

    test('Returns a promise when event is handled', () => {
      const item = DataGenerator.generateSavedItem();
      const element = fixture('BasicSaved');
      element.addEventListener('request-object-changed', function f(e) {
        element.removeEventListener('request-object-changed', f);
        e.preventDefault();
        e.detail.result = Promise.resolve();
      });
      return element._updateRequest(item);
    });
  });

  suite('_updateBulk()', () => {
    let element;
    setup(() => {
      element = fixture('BasicSaved');
    });

    function handleEvent(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    test('Calls _updateRequest() for each item', () => {
      const items = DataGenerator.generateRequests({
        requestsSize: 3
      });
      const spy = sinon.spy(element, '_updateRequest');
      element.addEventListener('request-object-changed', handleEvent);
      element._updateBulk(items);
      element.removeEventListener('request-object-changed', handleEvent);
      assert.equal(spy.callCount, 3);
      assert.deepEqual(spy.args[0][0], items[0]);
      assert.deepEqual(spy.args[1][0], items[1]);
      assert.deepEqual(spy.args[2][0], items[2]);
    });

    test('Returns a promise', () => {
      const items = DataGenerator.generateRequests({
        requestsSize: 1
      });
      element.addEventListener('request-object-changed', handleEvent);
      const result = element._updateBulk(items);
      element.removeEventListener('request-object-changed', handleEvent);
      assert.typeOf(result.then, 'function');
      return result;
    });
  });

  suite('_dispatchProjectUpdate()', () => {
    let element;
    setup(() => {
      element = fixture('BasicSaved');
      element.requests = DataGenerator.generateRequests({
        requestsSize: 3
      });
    });

    function handleEvent(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    test('Returns a promise', () => {
      const item = DataGenerator.createProjectObject();
      element.addEventListener('project-object-changed', handleEvent);
      const result = element._dispatchProjectUpdate(item);
      element.removeEventListener('project-object-changed', handleEvent);
      assert.typeOf(result.then, 'function');
      return result;
    });

    test('Calles _dispatch()', () => {
      const item = DataGenerator.createProjectObject();
      const spy = sinon.spy(element, '_dispatch');
      element.addEventListener('project-object-changed', handleEvent);
      const result = element._dispatchProjectUpdate(item);
      element.removeEventListener('project-object-changed', handleEvent);
      assert.isTrue(spy.called);
      assert.equal(spy.args[0][0], 'project-object-changed');
      return result;
    });

    test('Rejects when model not found', () => {
      const item = DataGenerator.createProjectObject();
      return element._dispatchProjectUpdate(item)
      .then(() => {
        throw new Error('Should not resolve');
      })
      .catch((cause) => {
        assert.equal(cause.message, 'Projects model not found');
      });
    });
  });

  suite('_projectChanged()', () => {
    let element;
    setup(() => {
      element = fixture('BasicSaved');
      element.project = DataGenerator.createProjectObject();
      element.type = 'project';
    });

    function fire(project, cancelable, node) {
      if (typeof cancelable === 'undefined') {
        cancelable = false;
      }
      const e = new CustomEvent('project-object-changed', {
        bubbles: true,
        cancelable,
        detail: {
          project
        }
      });
      (node || document.body).dispatchEvent(e);
      return e;
    }

    test('Updates the project', () => {
      const item = Object.assign({}, element.project);
      item.name = 'other-name';
      fire(item);
      assert.equal(element.project.name, 'other-name');
    });

    test('Calls _updateProjectOrder() with an argument', () => {
      const item = Object.assign({}, element.project);
      item.name = 'other-name';
      const spy = sinon.spy(element, '_updateProjectOrder');
      fire(item);
      assert.deepEqual(spy.args[0][0], item);
    });

    test('Ignores event when event is cancelable', () => {
      const item = Object.assign({}, element.project);
      item.name = 'other-name';
      fire(item, true);
      assert.notEqual(element.project.name, 'other-name');
    });

    test('Ignores event when type is not project', () => {
      const item = Object.assign({}, element.project);
      item.name = 'other-name';
      element.type = 'saved';
      fire(item);
      assert.notEqual(element.project.name, 'other-name');
    });

    test('Ignores event when project is not set', () => {
      const item = Object.assign({}, element.project);
      item.name = 'other-name';
      element.project = undefined;
      fire(item);
      assert.isUndefined(element.project);
    });

    test('Ignores event when disaptches by self', () => {
      const item = Object.assign({}, element.project);
      item.name = 'other-name';
      fire(item, false, element);
      assert.notEqual(element.project.name, 'other-name');
    });

    test('Will not set project if different id', () => {
      const item = Object.assign({}, element.project);
      item._id = 'other-id';
      fire(item);
      assert.notEqual(element.project._id, 'other-id');
    });
  });

  suite('_updateProjectOrder()', () => {
    function setupRequests(element) {
      const requests = [];
      for (let i = 0; i < 5; i++) {
        const request = DataGenerator.generateSavedItem({});
        request.projects = [element.project._id];
        element.project.requests.push(request._id);
        requests.push(request);
      }
      element.requests = requests;
    }

    let element;
    setup(() => {
      element = fixture('BasicSaved');
      element.project = DataGenerator.createProjectObject();
      element.type = 'project';
      element.project.requests = [];
      setupRequests(element);
    });

    test('Ignores call when no requests', () => {
      element.requests = undefined;
      const result = element._updateProjectOrder(element.project);
      assert.isFalse(result);
    });

    test('Ignores call when no requests on project', () => {
      element.project.requests = undefined;
      const result = element._updateProjectOrder(element.project);
      assert.isFalse(result);
    });

    test('Ignores call when requests lists are different size', () => {
      element.project.requests.splice(0, 1);
      const result = element._updateProjectOrder(element.project);
      assert.isFalse(result);
    });

    test('Ignores call when request cannot be find', () => {
      element.project.requests[0] = 'test-id';
      const result = element._updateProjectOrder(element.project);
      assert.isFalse(result);
    });

    test('Ignores call when request are equal', () => {
      const result = element._updateProjectOrder(element.project);
      assert.isFalse(result);
    });

    test('Updates list position', () => {
      const removed = element.project.requests.splice(0, 1);
      element.project.requests.splice(2, 0, removed[0]);
      const result = element._updateProjectOrder(element.project);
      assert.isTrue(result);
    });
  });

  suite('_persistRequestsOrder()', () => {
    let element;

    function handleEvent(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    setup(() => {
      element = fixture('BasicSaved');
      element.project = DataGenerator.createProjectObject();
      element.requests = DataGenerator.generateRequests({
        requestsSize: 3
      });
      element.type = 'project';
      element.addEventListener('project-object-changed', handleEvent);
    });

    teardown(() => {
      element.removeEventListener('project-object-changed', handleEvent);
    });

    test('Rejects when no project', () => {
      element.project = undefined;
      return element._persistRequestsOrder()
      .then(() => {
        throw new Error('Should not resolve');
      })
      .catch((cause) => {
        assert.equal(cause.message, '"project" is not set');
      });
    });

    test('Resolves unchanged when list of requests equals', () => {
      element.project.requests = element.requests.map((i) => i._id);
      const spy = sinon.spy(element, '_dispatchProjectUpdate');
      return element._persistRequestsOrder()
      .then(() => {
        assert.isFalse(spy.called);
      });
    });

    test('Calls _dispatchProjectUpdate() when new order detected', () => {
      element.project.requests = undefined;
      const spy = sinon.spy(element, '_dispatchProjectUpdate');
      return element._persistRequestsOrder()
      .then(() => {
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0]._id, element.project._id);
      });
    });

    test('Updates requests on the project', () => {
      element.project.requests = undefined;
      return element._persistRequestsOrder()
      .then(() => {
        assert.deepEqual(element.project.requests, element.requests.map((item) => item._id));
      });
    });
  });

  suite('_idsArrayEqual()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Returns true when both undefined', () => {
      const result = element._idsArrayEqual();
      assert.isTrue(result);
    });

    test('Returns true when both empty', () => {
      const result = element._idsArrayEqual([], []);
      assert.isTrue(result);
    });

    test('Returns true when has the same order', () => {
      const result = element._idsArrayEqual(['a', 'b'], ['a', 'b']);
      assert.isTrue(result);
    });

    test('Returns false when not the same order', () => {
      const result = element._idsArrayEqual(['b', 'a'], ['a', 'b']);
      assert.isFalse(result);
    });

    test('Returns false when different size', () => {
      const result = element._idsArrayEqual(['a'], ['a', 'b']);
      assert.isFalse(result);
    });

    test('Returns false when A is undefined', () => {
      const result = element._idsArrayEqual(undefined, ['a', 'b']);
      assert.isFalse(result);
    });

    test('Returns false when B is undefined', () => {
      const result = element._idsArrayEqual(['a', 'b'], undefined);
      assert.isFalse(result);
    });
  });

  suite('List types computations', () => {
    const iconWidthProperty = '--paper-item-icon-width';
    const iconWidths = ['72px', '48px', '36px'];

    suite('Default list type', () => {
      test(`Icon width is ${iconWidths[0]} for default list style`, (done) => {
        let style;
        const element = fixture('Default');
        flush(() => {
          if (window.ShadyCSS) {
            style = window.ShadyCSS.getComputedStyleValue(element, iconWidthProperty);
          } else {
            style = getComputedStyle(element).getPropertyValue(iconWidthProperty);
          }
          assert.equal(style.trim(), iconWidths[0]);
          done();
        });
      });

      test(`Icon width is ${iconWidths[0]} for inital list style`, (done) => {
        const element = fixture('Basic');
        flush(() => {
          let style;
          if (window.ShadyCSS) {
            style = window.ShadyCSS.getComputedStyleValue(element, iconWidthProperty);
          } else {
            style = getComputedStyle(element).getPropertyValue(iconWidthProperty);
          }
          assert.equal(style.trim(), iconWidths[0]);
          done();
        });
      });

      test('_hasTwoLines is computed for initial list type', () => {
        const element = fixture('Basic');
        assert.isTrue(element._hasTwoLines);
      });

      test('_hasTwoLines is computed for "default" list type', () => {
        const element = fixture('Default');
        assert.isTrue(element._hasTwoLines);
      });

      test('Calls notifyResize() when defined', (done) => {
        let called = false;
        const element = fixture('Default');
        element.notifyResize = () => called = true;
        element.listType = 'comfortable';
        flush(() => {
          assert.isTrue(called);
          done();
        });
      });
    });

    suite('Comfortable list type', () => {
      test('Icon width is ' + iconWidths[1], (done) => {
        let style;
        const element = fixture('Comfortable');
        flush(() => {
          if (window.ShadyCSS) {
            style = window.ShadyCSS.getComputedStyleValue(element, iconWidthProperty);
          } else {
            style = getComputedStyle(element).getPropertyValue(iconWidthProperty);
          }
          assert.equal(style, iconWidths[1]);
          done();
        });
      });

      test('_hasTwoLines is computed', () => {
        const element = fixture('Comfortable');
        assert.isFalse(element._hasTwoLines);
      });
    });

    suite('Compact list type', () => {
      test('Icon width is ' + iconWidths[2], (done) => {
        let style;
        const element = fixture('Compact');
        flush(() => {
          if (window.ShadyCSS) {
            style = window.ShadyCSS.getComputedStyleValue(element, iconWidthProperty);
          } else {
            style = getComputedStyle(element).getPropertyValue(iconWidthProperty);
          }
          assert.equal(style, iconWidths[2]);
          done();
        });
      });

      test('_hasTwoLines is computed', () => {
        const element = fixture('Compact');
        assert.isFalse(element._hasTwoLines);
      });
    });
  });

  suite('_dispatchExportData()', () => {
    let element;
    let opts;
    let requests;
    setup(() => {
      element = fixture('Basic');
      opts = {
        options: {options: true},
        providerOptions: {providerOptions: true}
      };
      requests = [{
        id: 'test-id'
      }];
    });

    test('Calls _dispatch()', () => {
      const spy = sinon.spy(element, '_dispatch');
      element._dispatchExportData(requests, opts);
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const e = element._dispatchExportData(requests, opts);
      assert.typeOf(e, 'customevent');
    });

    test('Event has type', () => {
      const e = element._dispatchExportData(requests, opts);
      assert.equal(e.type, 'arc-data-export');
    });

    test('Event has detail', () => {
      const e = element._dispatchExportData(requests, opts);
      assert.typeOf(e.detail, 'object');
    });

    test('Detail has options', () => {
      const e = element._dispatchExportData(requests, opts);
      assert.deepEqual(e.detail.options, opts.options);
    });

    test('Detail has providerOptions', () => {
      const e = element._dispatchExportData(requests, opts);
      assert.deepEqual(e.detail.providerOptions, opts.providerOptions);
    });

    test('Detail has history', () => {
      const e = element._dispatchExportData(requests, opts);
      assert.deepEqual(e.detail.data.history, requests);
    });

    test('Detail has saved', () => {
      element.type = 'saved';
      const e = element._dispatchExportData(requests, opts);
      assert.deepEqual(e.detail.data.saved, requests);
    });

    test('Detail has saved (project type)', () => {
      element.type = 'project';
      const e = element._dispatchExportData(requests, opts);
      assert.deepEqual(e.detail.data.saved, requests);
    });

    test('Detail has projects (project type)', () => {
      element.type = 'project';
      element.project = {testProject: true};
      const e = element._dispatchExportData(requests, opts);
      assert.deepEqual(e.detail.data.projects, [element.project]);
    });

    test('Throws when "type" is not set', () => {
      element.type = undefined;
      assert.throws(() => {
        element._dispatchExportData(requests, opts);
      }, 'The "type" property is not set.');
    });
  });

  suite('_openRequest()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Calls _dispatch()', () => {
      const spy = sinon.spy(element, '_dispatch');
      element._openRequest('test-id');
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const e = element._openRequest('test-id');
      assert.typeOf(e, 'customevent');
    });

    test('Event has type', () => {
      const e = element._openRequest('test-id');
      assert.equal(e.type, 'navigate');
    });

    test('Event has detail', () => {
      const e = element._openRequest('test-id');
      assert.typeOf(e.detail, 'object');
    });

    test('Detail has base', () => {
      const e = element._openRequest('test-id');
      assert.equal(e.detail.base, 'request');
    });

    test('Detail has type', () => {
      const e = element._openRequest('test-id');
      assert.equal(e.detail.type, element.type);
    });

    test('Sets type to saved when project', () => {
      element.type = 'project';
      const e = element._openRequest('test-id');
      assert.equal(e.detail.type, 'saved');
    });

    test('Detail has id', () => {
      const e = element._openRequest('test-id');
      assert.equal(e.detail.id, 'test-id');
    });

    test('Throws when "type" is not set', () => {
      element.type = undefined;
      assert.throws(() => {
        element._openRequest('test-id');
      }, 'The "type" property is not set.');
    });
  });

  suite('_validateType()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Passes validation for project type', () => {
      element._validateType('project');
    });

    test('Passes validation for saved type', () => {
      element._validateType('saved');
    });

    test('Passes validation for history type', () => {
      element._validateType('history');
    });

    test('Throws otherwise type', () => {
      assert.throws(() => {
        element._validateType('other');
      }, 'The "type" property is not set.');
    });
  });

  suite('readProjectRequests()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
    });

    test('Rejects when project read event is not handled', () => {
      return element.readProjectRequests('test')
      .then(() => {
        throw new Error('Should not resolve');
      })
      .catch((cause) => {
        assert.equal(cause.message, 'project-read event not handled');
      });
    });

    test('Rejects when requests read event is not handled', () => {
      element.addEventListener('project-read', function f(e) {
        element.removeEventListener('project-read', f);
        e.preventDefault();
        e.detail.result = Promise.resolve({
          id: 'test-project',
          requests: ['test-request']
        });
      });
      return element.readProjectRequests('test')
      .then(() => {
        throw new Error('Should not resolve');
      })
      .catch((cause) => {
        assert.equal(cause.message, 'request-project-list event not handled');
      });
    });

    test('Resolves to requests list', () => {
      element.addEventListener('project-read', function f(e) {
        element.removeEventListener('project-read', f);
        e.preventDefault();
        e.detail.result = Promise.resolve({
          id: 'test-project',
          requests: ['test-request']
        });
      });

      element.addEventListener('request-project-list', function f2(e) {
        element.removeEventListener('request-project-list', f2);
        e.preventDefault();
        e.detail.result = Promise.resolve([{
          id: 'test-request'
        }]);
      });
      return element.readProjectRequests('test')
      .then((result) => {
        assert.deepEqual(result, [{
          id: 'test-request'
        }]);
      });
    });
  });
  </script>
</body>
</html>
